
[meta
  title:"Netzwerk"
description:"my description" /]
[Header
  title:"K√úRZESTE WEGE IN NETZWERKEN"
  subtitle:"Am Beispiel des Floyd-Warshall Algorithmus"
  author:"D,T,B"/]
//[div className:"fixed"]
//[section className:"article-body"]
[var name:"dim" value:5 /]
[var name:"newMatrix" value: 0 /]
[var name:"step" value:0 /]
[var name:"k" value:1 /]
[var name:"i" value:2 /]
[var name:"j" value:2 /]
[var name:"ignite" value:0 /]
[var name:"k" value:1 /]
[var name:"visnum" value:0 /]


# Pathfinding in Networks

###Inhaltsverzeichnis

[Button onClick: `if (visnum==0){visnum=1}else{visnum=0}`] Change Vis [/Button]
[Fixed2 visnum:visnum]
  // wir brauchen hier ne componente, die nichts anzeigt, weil ich das anders
  // mit React nicht hinbekommen hab
  [blankComponent /]
  // Ducs Graph
  [Network /]

  [D3Matrix ignite:ignite i:i j:j k:k/]
  [Button onClick: `if(ignite==0){ignite=1;}else{ignite=0}`]Ignite![/Button]
  // das sieht jetzt relativ schei√üe aus, weil man nicht auf Sachen zugreifen,
  // welche in dem Ausdruck selber ver√§ndert werden
  // zB w√ºrde ich hier gerne oft auf "step" zugreifen, nachdem ich "step++" gemacht hab
  // Muss aber trotzdem immer "(step+1)" benutzen.
  [Button onClick: `
      step--;
      k = Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1;
  		j = (step-1)%(dim-1) +1;
      // if j>=k: j++
  		if (((step-1)%(dim-1) +1)>=(Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1)){
        j = (step-1)%(dim-1) +2;
  		};
  		i = Math.floor((step-1)/(dim-1))%(dim-1)+1;
      // if i>=k: i++
  		if ((Math.floor((step-1)/(dim-1))%(dim-1)+1)>=(Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1)){
  			i = Math.floor((step-1)/(dim-1))%(dim-1)+2;
  		};
      `]
  <[/Button] [Button onClick: `
      step++;
      k = Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1;
  		j = (step+1)%(dim-1) +1;
      // if j>=k: j++
  		if (((step+1)%(dim-1) +1)>=(Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1)){
        j = (step+1)%(dim-1) +2;
  		};
  		i = Math.floor((step+1)/(dim-1))%(dim-1)+1;
      // if i>=k: i++
  		if ((Math.floor((step+1)/(dim-1))%(dim-1)+1)>=(Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1)){
  			i = Math.floor((step+1)/(dim-1))%(dim-1)+2;
  		};
      `]
  >[/Button]
[/Fixed2]

k=[Display value:k /],
j=[Display value:j /],
i=[Display value:i /],
step = [Display value:step /]
visnum = [Display value:visnum /]
[Button onClick: `if(ignite==0){ignite=1;}else{ignite=0}`]Ignite![/Button]
// das sieht jetzt relativ schei√üe aus, weil man nicht auf Sachen zugreifen,
// welche in dem Ausdruck selber ver√§ndert werden
// zB w√ºrde ich hier gerne oft auf "step" zugreifen, nachdem ich "step++" gemacht hab
// Muss aber trotzdem immer "(step+1)" benutzen.
[Button onClick: `
    step--;
    k = Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1;
    j = (step-1)%(dim-1) +1;
    // if j>=k: j++
    if (((step-1)%(dim-1) +1)>=(Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1)){
      j = (step-1)%(dim-1) +2;
    };
    i = Math.floor((step-1)/(dim-1))%(dim-1)+1;
    // if i>=k: i++
    if ((Math.floor((step-1)/(dim-1))%(dim-1)+1)>=(Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1)){
      i = Math.floor((step-1)/(dim-1))%(dim-1)+2;
    };
    `]
<[/Button] [Button onClick: `
    step++;
    k = Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1;
    j = (step+1)%(dim-1) +1;
    // if j>=k: j++
    if (((step+1)%(dim-1) +1)>=(Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1)){
      j = (step+1)%(dim-1) +2;
    };
    i = Math.floor((step+1)/(dim-1))%(dim-1)+1;
    // if i>=k: i++
    if ((Math.floor((step+1)/(dim-1))%(dim-1)+1)>=(Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1)){
      i = Math.floor((step+1)/(dim-1))%(dim-1)+2;
    };
    `]
>[/Button]

Pics von wikipedia (public domain) [link text:"Graph" url:"https://de.wikipedia.org/wiki/Graph_(Graphentheorie)" /]
## Netzwerk
Ein Netzwerk besteht aus einer Menge von eindeutigen Punkten, die Knoten genannt werden.

[SVG src:"static/images/Nodes2.svg" /]
[br/]
Diese Knoten k√∂nnen durch sogenannte Kanten verbunden sein. Gilt die Kante zwischen zwei Knoten
f√ºr beide Richtungen, so spricht man von einem ungerichteten Graphen
//(Netzwerk w√§re hier iwie falsch).

[SVG src:"static/images/Undirected2.svg" /]

Im Gegenteil kann auch eine Kante nur f√ºr eine Richtung gelten. Deshalb wird der folgende Graph auch
gerichteter Graph genannt.

[SVG src:"static/images/Directed3.svg" /]

Au√üerdem kann jede Kante ein Gewicht haben. Das n√§chste Bild zeigt einen vollst√§ndigen Graphen.

[SVG src:"static/images/WithWeights.svg" /]


[action onClick:`alert('üëç üéâ');`]action links[/action]


##Der Floyd-Warshall-Algorithmus

Der Floyd-Warshall-Algorithmus nutzt das Prinzip der dynamischen Programmierung, um in einem gewichteten Graphen den k√ºrzesten Pfad zwischen allen Paaren von Knoten zu berechnen.
Der Algorithmus vergleicht f√ºr alle Knoten mit Index k zwischen 1 und N (der Anzahl der Knoten des Graphen), ob der bisher bekannte Pfad zwischen Knotenpaaren verk√ºrzt wird wenn er √ºber den Knoten k f√ºhrt (und sich damit aus den 2 Teilpfaden von den Knoten zu k zusammensetzt) oder nicht.
Dabei wird die Matrix f√ºr jeden Knoten k von 1 bis N aufgerufen, ver√§ndert und dann als Grundlage f√ºr die n√§chste Iteration verwendet.
Als Pseudocode sieht dies so aus:

[D3Pseudocode className:"d3-component" newPseudocode:newPseudocode state:state i:i k:k j:j/]
