
[meta
  title:"Netzwerk"
description:"my description" /]
[Header
  title:"K√úRZESTE WEGE IN NETZWERKEN"
  subtitle:"Am Beispiel des Floyd-Warshall Algorithmus"
  author:"D,T,B"/]
//[div className:"fixed"]
//[section className:"article-body"]
[var name:"dim" value:5 /]
[var name:"newMatrix" value: 0 /]
[var name:"step" value:0 /]
[var name:"k" value:1 /]
[var name:"i" value:2 /]
[var name:"j" value:2 /]
[var name:"ignite" value:0 /]
[var name:"k" value:1 /]
[var name:"visnum" value:0 /]


# Pathfinding in Networks

###Inhaltsverzeichnis

[Button onClick: `if (visnum==0){visnum=1}else{visnum=0}`] Change Vis [/Button]
[Fixed2 visnum:visnum]
  // wir brauchen hier ne componente, die nichts anzeigt, weil ich das anders
  // mit React nicht hinbekommen hab
  [blankComponent /]
  // Ducs Graph
  [Network /]

  [D3Matrix ignite:ignite i:i j:j k:k/]
  [Button onClick: `if(ignite==0){ignite=1;}else{ignite=0}`]Ignite![/Button]
  // das sieht jetzt relativ schei√üe aus, weil man nicht auf Sachen zugreifen,
  // welche in dem Ausdruck selber ver√§ndert werden
  // zB w√ºrde ich hier gerne oft auf "step" zugreifen, nachdem ich "step++" gemacht hab
  // Muss aber trotzdem immer "(step+1)" benutzen.
  [Button onClick: `
      step--;
      k = Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1;
  		j = (step-1)%(dim-1) +1;
      // if j>=k: j++
  		if (((step-1)%(dim-1) +1)>=(Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1)){
        j = (step-1)%(dim-1) +2;
  		};
  		i = Math.floor((step-1)/(dim-1))%(dim-1)+1;
      // if i>=k: i++
  		if ((Math.floor((step-1)/(dim-1))%(dim-1)+1)>=(Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1)){
  			i = Math.floor((step-1)/(dim-1))%(dim-1)+2;
  		};
      `]
  <[/Button] [Button onClick: `
      step++;
      k = Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1;
  		j = (step+1)%(dim-1) +1;
      // if j>=k: j++
  		if (((step+1)%(dim-1) +1)>=(Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1)){
        j = (step+1)%(dim-1) +2;
  		};
  		i = Math.floor((step+1)/(dim-1))%(dim-1)+1;
      // if i>=k: i++
  		if ((Math.floor((step+1)/(dim-1))%(dim-1)+1)>=(Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1)){
  			i = Math.floor((step+1)/(dim-1))%(dim-1)+2;
  		};
      `]
  >[/Button]
[/Fixed2]

k=[Display value:k /],
j=[Display value:j /],
i=[Display value:i /],
step = [Display value:step /]
visnum = [Display value:visnum /]
[Button onClick: `if(ignite==0){ignite=1;}else{ignite=0}`]Ignite![/Button]
// das sieht jetzt relativ schei√üe aus, weil man nicht auf Sachen zugreifen,
// welche in dem Ausdruck selber ver√§ndert werden
// zB w√ºrde ich hier gerne oft auf "step" zugreifen, nachdem ich "step++" gemacht hab
// Muss aber trotzdem immer "(step+1)" benutzen.
[Button onClick: `
    step--;
    k = Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1;
    j = (step-1)%(dim-1) +1;
    // if j>=k: j++
    if (((step-1)%(dim-1) +1)>=(Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1)){
      j = (step-1)%(dim-1) +2;
    };
    i = Math.floor((step-1)/(dim-1))%(dim-1)+1;
    // if i>=k: i++
    if ((Math.floor((step-1)/(dim-1))%(dim-1)+1)>=(Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1)){
      i = Math.floor((step-1)/(dim-1))%(dim-1)+2;
    };
    `]
<[/Button] [Button onClick: `
    step++;
    k = Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1;
    j = (step+1)%(dim-1) +1;
    // if j>=k: j++
    if (((step+1)%(dim-1) +1)>=(Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1)){
      j = (step+1)%(dim-1) +2;
    };
    i = Math.floor((step+1)/(dim-1))%(dim-1)+1;
    // if i>=k: i++
    if ((Math.floor((step+1)/(dim-1))%(dim-1)+1)>=(Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1)){
      i = Math.floor((step+1)/(dim-1))%(dim-1)+2;
    };
    `]
>[/Button]

Pics von wikipedia (public domain) [link text:"Graph" url:"https://de.wikipedia.org/wiki/Graph_(Graphentheorie)" /]
## Netzwerk
Ein Netzwerk besteht aus einer Menge von eindeutigen Punkten, die Knoten genannt werden.

[SVG src:"static/images/Nodes2.svg" /]
[br/]
Diese Knoten k√∂nnen durch sogenannte Kanten verbunden sein. Gilt die Kante zwischen zwei Knoten
f√ºr beide Richtungen, so spricht man von einem ungerichteten Graphen
//(Netzwerk w√§re hier iwie falsch).

[SVG src:"static/images/Undirected2.svg" /]

Im Gegenteil kann auch eine Kante nur f√ºr eine Richtung gelten. Deshalb wird der folgende Graph auch
gerichteter Graph genannt.

[SVG src:"static/images/Directed3.svg" /]

Au√üerdem kann jede Kante ein Gewicht haben. Das n√§chste Bild zeigt einen vollst√§ndigen Graphen.

[SVG src:"static/images/WithWeights.svg" /]


[action onClick:`alert('üëç üéâ');`]action links[/action]


###Der Floyd-Warshall-Algorithmus

Hier fehlt der Text noch..
in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.
Excepteur sint occaecat cupidatat non proident,
sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
ut labore et dolore magna aliqua. Ut enim ad minim
veniam, quis nostrud exercitation ullamco laboris nisi ut
aliquip ex ea commodo consequat. Duis aute irure dolor
in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.
Excepteur sint occaecat cupidatat non proident,

[D3Pseudocode className:"d3-component" newPseudocode:newPseudocode state:state i:i k:k j:j/]

sunt in culpa qui officia deserunt mollit anim id est laborum.Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
ut labore et dolore magna aliqua. Ut enim ad minim
veniam, quis nostrud exercitation ullamco laboris nisi ut
aliquip ex ea commodo consequat. Duis aute irure dolor
in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.

