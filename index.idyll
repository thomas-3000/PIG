
[meta
  title:"Netzwerk"
description:"my description" /]
[Header
  title:"K√úRZESTE WEGE IN NETZWERKEN"
  subtitle:"Am Beispiel des Floyd-Warshall Algorithmus"
  author:"Duc, Thomas, Ben"/]
//[div className:"fixed"]
//[section className:"article-body"]
[var name:"dim" value:5 /]
[var name:"newMatrix" value: 0 /]
[var name:"step" value:0 /]
[var name:"k" value:1 /]
[var name:"i" value:2 /]
[var name:"j" value:2 /]
[var name:"ignite" value:0 /]
[var name:"visnum" value:0 /]


// [action onClick:`alert('üëç üéâ');`]action links[/action]

// ###Inhaltsverzeichnis

[Fixed2 visnum:visnum]
  // wir brauchen hier ne componente, die nichts anzeigt, weil ich das anders
  // mit React nicht hinbekommen hab
  [blankComponent /]
  // Ducs Graph
  [p]###Klicke zwei Knoten an[/p]
  [NetworkClick /]

  [D3Matrix ignite:ignite i:i j:j k:k/]
  // das sieht jetzt relativ schei√üe aus, weil man nicht auf Sachen zugreifen,
  // welche in dem Ausdruck selber ver√§ndert werden
  // zB w√ºrde ich hier gerne oft auf "step" zugreifen, nachdem ich "step++" gemacht hab
  // Muss aber trotzdem immer "(step+1)" benutzen.
  [Button onClick: `
      step--;
      k = Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1;
  		j = (step-1)%(dim-1) +1;
      // if j>=k: j++
  		if (((step-1)%(dim-1) +1)>=(Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1)){
        j = (step-1)%(dim-1) +2;
  		};
  		i = Math.floor((step-1)/(dim-1))%(dim-1)+1;
      // if i>=k: i++
  		if ((Math.floor((step-1)/(dim-1))%(dim-1)+1)>=(Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1)){
  			i = Math.floor((step-1)/(dim-1))%(dim-1)+2;
  		};
      `]
  <[/Button] [Button onClick: `
      step++;
      k = Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1;
  		j = (step+1)%(dim-1) +1;
      // if j>=k: j++
  		if (((step+1)%(dim-1) +1)>=(Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1)){
        j = (step+1)%(dim-1) +2;
  		};
  		i = Math.floor((step+1)/(dim-1))%(dim-1)+1;
      // if i>=k: i++
  		if ((Math.floor((step+1)/(dim-1))%(dim-1)+1)>=(Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1)){
  			i = Math.floor((step+1)/(dim-1))%(dim-1)+2;
  		};
      `]
  >[/Button]
[/Fixed2]

// k=[Display value:k /],
// j=[Display value:j /],
// i=[Display value:i /],
// step = [Display value:step /]

// Pics von wikipedia (public domain) [link text:"Graph" url:"https://de.wikipedia.org/wiki/Graph_(Graphentheorie)" /]
## Was ist ein Netzwerk?
Ein Netzwerk besteht aus einer Menge von eindeutigen Punkten, die Knoten genannt werden.

[SVG src:"static/images/Nodes4.svg" /]
[br/]
Diese Knoten k√∂nnen durch sogenannte Kanten verbunden sein. Gilt die Kante zwischen zwei Knoten
f√ºr beide Richtungen, so spricht man von einem ungerichteten Graphen
//(Netzwerk w√§re hier iwie falsch).

[SVG src:"static/images/Undirected4.svg" /]

Im Gegenteil kann auch eine Kante nur f√ºr eine Richtung gelten. Deshalb wird der folgende Graph auch
gerichteter Graph genannt.

[SVG src:"static/images/Directed5.svg" /]

Au√üerdem kann jede Kante ein Gewicht haben. Das n√§chste Bild zeigt einen vollst√§ndigen Graphen.

[SVG src:"static/images/WithWeights2.svg" /]

Jedes Netzwerk ist definiert durch die Anzahl der Knoten und die Kanten, welche sie verbinden. Dadurch kann man
zu jeden Netzwerk eine Matrix angeben, die die Verbindungen des Netzwerks abbildet. Diese Matrix wird [link text:"Adjazenzmatrix" url:"https://de.wikipedia.org/wiki/Adjazenzmatrix" /] genannt. Der Matrixeintrag mit Spalte 1 und Zeile 2
gibt dann das Gewicht der Verbindung von Knoten 1 zum Knoten 2 an. Gibt es keine Verbindung von 1 nach 2, dann wird das Gewicht als
unendlich aufgefasst.
[SmallD3Matrix /]

## Dynamische Programmierung
Dynamische Programmierung ist eine Methode zum algorithmischen L√∂sen eines Optimierungsproblems, indem dieses in gleichartige Teilprobleme zerlegt wird und die Zwischenresultaten systematische gespeichert werden.
Wie die Teile-und-Beherrsche-Methode l√∂st die dynamische Programmierung Probleme, indem sie die L√∂sungen von Teilproblemen kombiniert. Diese Teilprobleme k√∂nnen sich dabei √ºberlappen,
d.h. wenn die Teilprobleme ihrerseits jeweils die gleichen Teil-Teil-probleme l√∂sen m√ºssen. Das DP l√∂st jedes Teilproblem genau einmal und speichert dessen L√∂sung als Teilergebnis in einer Tabelle oder auch Matrix
ab. Dadurch vermeiden wir den Aufwand, die L√∂sung eines Teilteilproblems jedes Mal wieder neu zu berechnen, wenn es uns wieder begegnet.

Als einer der klassischen Vertreter der dynamischen Programmierung kann der Floyd-Warshall-Algorithmus das k√ºrzeste-Pfad-Problem f√ºr alle Knotenpaare auf einen gerichteten Graphen l√∂sen.



##Der Floyd-Warshall-Algorithmus

Der Floyd-Warshall-Algorithmus nutzt das Prinzip der dynamischen Programmierung, um in einem gewichteten Graphen den k√ºrzesten Pfad zwischen allen Paaren von Knoten zu berechnen.
F√ºr alle Knoten mit dem Index k zwischen 1 und N (N ist die Anzahl der Knoten des Graphen) wird √ºberpr√ºft, ob der bisher bekannte Pfad zwischen Knotenpaaren verk√ºrzt wird wenn er
√ºber den Knoten k f√ºhrt (und sich damit aus den 2 Teilpfaden von den Knoten zu k zusammensetzt) oder nicht.
Dabei wird die Matrix f√ºr jeden Knoten k von 1 bis N aufgerufen, die Ver√§nderungen werden gespeichert und dann als Grundlage f√ºr die n√§chste Iteration verwendet.

Unten siehst du das gleiche Netzerk, wie rechts. Um die Adjazensmatrix des Netzwerks zu sehen, dr√ºcke [action onClick:`if(visnum==0){visnum=1}else{visnum=0};`]hier[/action].
[NetworkSteps i:i j:j k:k/]
[Button onClick: `
    step--;
    k = Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1;
    j = (step-1)%(dim-1) +1;
    // if j>=k: j++
    if (((step-1)%(dim-1) +1)>=(Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1)){
      j = (step-1)%(dim-1) +2;
    };
    i = Math.floor((step-1)/(dim-1))%(dim-1)+1;
    // if i>=k: i++
    if ((Math.floor((step-1)/(dim-1))%(dim-1)+1)>=(Math.floor( (step-1)/((dim-1)*(dim-1)))%(dim)+1)){
      i = Math.floor((step-1)/(dim-1))%(dim-1)+2;
    };
    `]
<[/Button] [Button onClick: `
    step++;
    k = Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1;
    j = (step+1)%(dim-1) +1;
    // if j>=k: j++
    if (((step+1)%(dim-1) +1)>=(Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1)){
      j = (step+1)%(dim-1) +2;
    };
    i = Math.floor((step+1)/(dim-1))%(dim-1)+1;
    // if i>=k: i++
    if ((Math.floor((step+1)/(dim-1))%(dim-1)+1)>=(Math.floor( (step+1)/((dim-1)*(dim-1)))%(dim)+1)){
      i = Math.floor((step+1)/(dim-1))%(dim-1)+2;
    };
    `]
>[/Button]

Der Pseudocode unten zeigt dir welcher Vergleich f√ºr jede Iteration gemacht wird.

[D3Pseudocode className:"d3-component" newPseudocode:newPseudocode state:state i:i k:k j:j/]


Nachdem du ein paar Schritte durchgegangen bist, hast du das Prinzip bestimmt verstanden. Wir hoffen mit der Visualisierung
geholfen zu haben!

Lizenz: [link text:"CC-BY-SA 2.0" url:"https://creativecommons.org/licenses/by-sa/2.0/" /]
## Resultat des Algorithmus
Die urspr√ºngliche Matrix sah so aus:
[D3Matrix /]
Die finale Matrix sieht nun so aus:
[D3FinalMatrix ignite:0 i:4 j:4 k:5/]
